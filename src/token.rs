use super::*;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) enum NumberKind {
  Decimal,
  Float,
  Hexadecimal,
  Scientific,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) struct NumberLiteral {
  pub(crate) kind: NumberKind,
  pub(crate) lexeme: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) enum Token {
  AndAnd,
  Assign,
  BangEqual,
  BangTilde,
  Begin,
  Break,
  Caret,
  CaretAssign,
  Case,
  Colon,
  Comma,
  Continue,
  Default,
  Delete,
  Do,
  Dollar,
  Else,
  End,
  EqualEqual,
  For,
  Function,
  Getline,
  Greater,
  GreaterEqual,
  GreaterGreater,
  Identifier(String),
  If,
  In,
  LBrace,
  LBracket,
  LParen,
  Less,
  LessEqual,
  Minus,
  MinusAssign,
  MinusMinus,
  Next,
  Number(NumberLiteral),
  OrOr,
  Percent,
  PercentAssign,
  Pipe,
  Plus,
  PlusAssign,
  PlusPlus,
  Print,
  Printf,
  Question,
  RBrace,
  RBracket,
  RParen,
  Return,
  Semicolon,
  Slash,
  SlashAssign,
  Star,
  StarAssign,
  String(String),
  Switch,
  Tilde,
  While,
}

impl Display for Token {
  fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
    match self {
      Self::AndAnd => write!(f, "&&"),
      Self::Assign => write!(f, "="),
      Self::BangEqual => write!(f, "!="),
      Self::BangTilde => write!(f, "!~"),
      Self::Begin => write!(f, "BEGIN"),
      Self::Break => write!(f, "break"),
      Self::Caret => write!(f, "^"),
      Self::CaretAssign => write!(f, "^="),
      Self::Case => write!(f, "case"),
      Self::Colon => write!(f, ":"),
      Self::Comma => write!(f, ","),
      Self::Continue => write!(f, "continue"),
      Self::Default => write!(f, "default"),
      Self::Delete => write!(f, "delete"),
      Self::Do => write!(f, "do"),
      Self::Dollar => write!(f, "$"),
      Self::Else => write!(f, "else"),
      Self::End => write!(f, "END"),
      Self::EqualEqual => write!(f, "=="),
      Self::For => write!(f, "for"),
      Self::Function => write!(f, "function"),
      Self::Getline => write!(f, "getline"),
      Self::Greater => write!(f, ">"),
      Self::GreaterEqual => write!(f, ">="),
      Self::GreaterGreater => write!(f, ">>"),
      Self::Identifier(identifier) => write!(f, "{identifier}"),
      Self::If => write!(f, "if"),
      Self::In => write!(f, "in"),
      Self::Number(number) => write!(f, "{}", number.lexeme),
      Self::LBrace => write!(f, "{{"),
      Self::LBracket => write!(f, "["),
      Self::LParen => write!(f, "("),
      Self::Less => write!(f, "<"),
      Self::LessEqual => write!(f, "<="),
      Self::Minus => write!(f, "-"),
      Self::MinusAssign => write!(f, "-="),
      Self::MinusMinus => write!(f, "--"),
      Self::Next => write!(f, "next"),
      Self::OrOr => write!(f, "||"),
      Self::Percent => write!(f, "%"),
      Self::PercentAssign => write!(f, "%="),
      Self::Pipe => write!(f, "|"),
      Self::Plus => write!(f, "+"),
      Self::PlusAssign => write!(f, "+="),
      Self::PlusPlus => write!(f, "++"),
      Self::Print => write!(f, "print"),
      Self::Printf => write!(f, "printf"),
      Self::Question => write!(f, "?"),
      Self::RBrace => write!(f, "}}"),
      Self::RBracket => write!(f, "]"),
      Self::RParen => write!(f, ")"),
      Self::Return => write!(f, "return"),
      Self::Semicolon => write!(f, ";"),
      Self::Slash => write!(f, "/"),
      Self::SlashAssign => write!(f, "/="),
      Self::Star => write!(f, "*"),
      Self::StarAssign => write!(f, "*="),
      Self::String(string) => write!(f, "\"{string}\""),
      Self::Switch => write!(f, "switch"),
      Self::Tilde => write!(f, "~"),
      Self::While => write!(f, "while"),
    }
  }
}
